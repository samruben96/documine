<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>5</storyId>
    <title>Error Handling &amp; Logging Patterns</title>
    <status>drafted</status>
    <generatedAt>2025-11-25</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-5-error-handling-logging-patterns.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>consistent error handling and structured logging across the application</iWant>
    <soThat>errors are handled gracefully and debugging is straightforward</soThat>
    <tasks>
      <task id="1" ac="1.5.1">
        <title>Create Custom Error Classes</title>
        <subtasks>
          <subtask>Create documine/src/lib/errors.ts</subtask>
          <subtask>Implement DocumentNotFoundError with code 'DOCUMENT_NOT_FOUND'</subtask>
          <subtask>Implement UnauthorizedError with code 'UNAUTHORIZED'</subtask>
          <subtask>Implement ProcessingError with code 'PROCESSING_ERROR'</subtask>
          <subtask>Implement ValidationError with code 'VALIDATION_ERROR'</subtask>
          <subtask>Export all error classes</subtask>
          <subtask>Add TypeScript types for error codes (union type)</subtask>
        </subtasks>
      </task>
      <task id="2" ac="1.5.2">
        <title>Create API Response Helpers</title>
        <subtasks>
          <subtask>Create documine/src/lib/utils/api-response.ts</subtask>
          <subtask>Define ApiResponse&lt;T&gt; type with success/error union</subtask>
          <subtask>Define ApiError type: { code, message, details? }</subtask>
          <subtask>Implement successResponse&lt;T&gt;(data): Response</subtask>
          <subtask>Implement errorResponse(code, message, status, details?): Response</subtask>
          <subtask>Add JSDoc documentation</subtask>
          <subtask>Export from @/lib/utils/index.ts barrel</subtask>
        </subtasks>
      </task>
      <task id="3" ac="1.5.3">
        <title>Create Structured Logger</title>
        <subtasks>
          <subtask>Create documine/src/lib/utils/logger.ts</subtask>
          <subtask>Implement log.info(message, data?)</subtask>
          <subtask>Implement log.warn(message, data?)</subtask>
          <subtask>Implement log.error(message, error, data?)</subtask>
          <subtask>Output JSON: { level, message, timestamp: ISO-8601, ...data }</subtask>
          <subtask>Error method includes error message and stack</subtask>
          <subtask>Export log from @/lib/utils/index.ts barrel</subtask>
        </subtasks>
      </task>
      <task id="4" ac="1.5.4">
        <title>Create Error Boundary Components</title>
        <subtasks>
          <subtask>Create documine/src/app/error.tsx (App Router error boundary)</subtask>
          <subtask>Create documine/src/app/global-error.tsx (Root error boundary)</subtask>
          <subtask>Show "Something went wrong" message</subtask>
          <subtask>Add "Try again" button calling reset function</subtask>
          <subtask>Log error details via logger</subtask>
          <subtask>Style with Tailwind (Trustworthy Slate #475569)</subtask>
          <subtask>Do not leak technical details to users</subtask>
        </subtasks>
      </task>
      <task id="5" ac="1.5.2">
        <title>Create Test API Route</title>
        <subtasks>
          <subtask>Create documine/src/app/api/test-errors/route.ts</subtask>
          <subtask>GET endpoint demonstrating error response format</subtask>
          <subtask>POST with ?type= query param for different error types</subtask>
          <subtask>Use error classes and response helpers correctly</subtask>
          <subtask>Add logging calls to demonstrate logger</subtask>
        </subtasks>
      </task>
      <task id="6" ac="1.5.2,1.5.3">
        <title>Update Barrel Exports</title>
        <subtasks>
          <subtask>Update documine/src/lib/utils/index.ts with new exports</subtask>
          <subtask>Create documine/src/lib/index.ts re-exporting errors and utils</subtask>
        </subtasks>
      </task>
      <task id="7" ac="1.5.5">
        <title>Verify Build</title>
        <subtasks>
          <subtask>Run npm run build in documine directory</subtask>
          <subtask>Verify no TypeScript errors</subtask>
          <subtask>Verify build completes successfully</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-1.5.1">
      <description>Custom error classes defined in @/lib/errors.ts</description>
      <details>
        - DocumentNotFoundError with code 'DOCUMENT_NOT_FOUND'
        - UnauthorizedError with code 'UNAUTHORIZED'
        - ProcessingError with code 'PROCESSING_ERROR'
        - ValidationError with code 'VALIDATION_ERROR'
        - Each class extends Error and has a code property
      </details>
    </criterion>
    <criterion id="AC-1.5.2">
      <description>API routes return consistent response format via @/lib/utils/api-response.ts</description>
      <details>
        - Success: { data: T, error: null }
        - Error: { data: null, error: { code: string, message: string, details?: unknown } }
        - Helper functions: successResponse(data) and errorResponse(code, message, status, details?)
      </details>
    </criterion>
    <criterion id="AC-1.5.3">
      <description>Structured logger implemented in @/lib/utils/logger.ts</description>
      <details>
        - log.info(message, data?) - JSON formatted with timestamp, level: 'info'
        - log.error(message, error, data?) - includes stack trace, level: 'error'
        - log.warn(message, data?) - level: 'warn'
        - Output format: { level, message, timestamp, ...data }
      </details>
    </criterion>
    <criterion id="AC-1.5.4">
      <description>Error boundaries exist for React error handling</description>
      <details>
        - Global error boundary catches unhandled React errors
        - Shows user-friendly error message with retry option
        - Logs error details for debugging
      </details>
    </criterion>
    <criterion id="AC-1.5.5">
      <description>Build succeeds with npm run build after all changes</description>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Error Handling</section>
        <snippet>Application errors use custom error classes with code property. API routes catch errors and return { data: null, error: { code, message } } format.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Logging Strategy</section>
        <snippet>Structured JSON logging with log.info, log.error, log.warn methods. Output format: { level, message, timestamp: ISO-8601, ...data }.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Implementation Patterns - API Response Format</section>
        <snippet>All API responses follow { data: T | null, error: ErrorObject | null } structure for consistency.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Epic 1 Technical Specification</title>
        <section>Story 1.5 Acceptance Criteria</section>
        <snippet>Defines AC-1.5.1 through AC-1.5.5 with detailed error class, API response, logger, and error boundary requirements.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 1.5: Error Handling &amp; Logging Patterns</section>
        <snippet>Developer story for consistent error handling and structured logging. Addresses FR34 (clear error messages).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/1-4-storage-bucket-configuration.md</path>
        <title>Previous Story (1.4)</title>
        <section>Dev Agent Record</section>
        <snippet>Established barrel export pattern in src/lib/utils/index.ts. Created test API route at /api/test-storage as reference pattern.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>documine/src/lib/utils/storage.ts</path>
        <kind>utility</kind>
        <symbol>uploadDocument, getDocumentUrl, deleteDocument</symbol>
        <lines>1-82</lines>
        <reason>Reference pattern for utility functions with JSDoc documentation, TypeScript types, and error throwing</reason>
      </file>
      <file>
        <path>documine/src/lib/utils/index.ts</path>
        <kind>barrel</kind>
        <symbol>exports</symbol>
        <lines>1</lines>
        <reason>Barrel export pattern to follow - currently exports storage functions, needs update for new modules</reason>
      </file>
      <file>
        <path>documine/src/app/api/test-storage/route.ts</path>
        <kind>api-route</kind>
        <symbol>GET</symbol>
        <lines>1-99</lines>
        <reason>Reference pattern for test API route with NextResponse.json, try-catch, structured response</reason>
      </file>
      <file>
        <path>documine/src/lib/supabase/server.ts</path>
        <kind>client</kind>
        <symbol>createClient, createServiceClient</symbol>
        <reason>Server-side Supabase client patterns that error handlers may interact with</reason>
      </file>
      <file>
        <path>documine/src/app/layout.tsx</path>
        <kind>layout</kind>
        <reason>Root layout where global-error.tsx will be a sibling. Check for existing error handling patterns.</reason>
      </file>
      <file>
        <path>documine/src/app/page.tsx</path>
        <kind>page</kind>
        <reason>Example page component. error.tsx will be sibling to handle route errors.</reason>
      </file>
    </code>
    <dependencies>
      <node>
        <package name="next" version="16.0.4">React framework with App Router, provides error.tsx and global-error.tsx conventions</package>
        <package name="react" version="19.2.0">UI library for error boundary components</package>
        <package name="typescript" version="^5">Type safety for error classes and interfaces</package>
        <package name="tailwindcss" version="^4">Styling for error boundary UI</package>
        <package name="zod" version="^4.1.13">Schema validation (can be used with ValidationError)</package>
        <package name="@supabase/supabase-js" version="^2.84.0">Database client that may throw errors to handle</package>
        <package name="lucide-react" version="^0.554.0">Icons for error UI (e.g., AlertTriangle)</package>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="docs/architecture.md#Error-Handling">
      Error classes must have a code property as const for type safety. Use instanceof checks in catch blocks.
    </constraint>
    <constraint source="docs/architecture.md#API-Response-Format">
      All API responses must follow { data: T | null, error: ErrorObject | null } structure. Never mix success and error.
    </constraint>
    <constraint source="docs/architecture.md#Logging-Strategy">
      Logger outputs JSON to console. Include timestamp in ISO-8601 format. Error method must include stack trace.
    </constraint>
    <constraint source="Next.js App Router">
      error.tsx handles route segment errors. global-error.tsx handles root layout errors. Both must be client components ('use client').
    </constraint>
    <constraint source="docs/ux-design-specification.md">
      Error UI uses Trustworthy Slate theme (#475569). No technical details exposed to users. Provide clear recovery action.
    </constraint>
    <constraint source="Previous stories">
      Follow barrel export pattern from src/lib/utils/index.ts. Follow test API route pattern from /api/test-storage.
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ApiResponse&lt;T&gt;</name>
      <kind>type</kind>
      <signature>type ApiResponse&lt;T&gt; = { data: T; error: null } | { data: null; error: ApiError }</signature>
      <path>documine/src/lib/utils/api-response.ts (NEW)</path>
    </interface>
    <interface>
      <name>ApiError</name>
      <kind>type</kind>
      <signature>type ApiError = { code: string; message: string; details?: unknown }</signature>
      <path>documine/src/lib/utils/api-response.ts (NEW)</path>
    </interface>
    <interface>
      <name>successResponse</name>
      <kind>function</kind>
      <signature>function successResponse&lt;T&gt;(data: T): Response</signature>
      <path>documine/src/lib/utils/api-response.ts (NEW)</path>
    </interface>
    <interface>
      <name>errorResponse</name>
      <kind>function</kind>
      <signature>function errorResponse(code: string, message: string, status: number, details?: unknown): Response</signature>
      <path>documine/src/lib/utils/api-response.ts (NEW)</path>
    </interface>
    <interface>
      <name>log</name>
      <kind>object</kind>
      <signature>const log: { info(msg: string, data?): void; warn(msg: string, data?): void; error(msg: string, err: Error, data?): void }</signature>
      <path>documine/src/lib/utils/logger.ts (NEW)</path>
    </interface>
    <interface>
      <name>DocumentNotFoundError</name>
      <kind>class</kind>
      <signature>class DocumentNotFoundError extends Error { code: 'DOCUMENT_NOT_FOUND'; constructor(documentId: string) }</signature>
      <path>documine/src/lib/errors.ts (NEW)</path>
    </interface>
    <interface>
      <name>UnauthorizedError</name>
      <kind>class</kind>
      <signature>class UnauthorizedError extends Error { code: 'UNAUTHORIZED'; constructor(message?: string) }</signature>
      <path>documine/src/lib/errors.ts (NEW)</path>
    </interface>
    <interface>
      <name>ProcessingError</name>
      <kind>class</kind>
      <signature>class ProcessingError extends Error { code: 'PROCESSING_ERROR'; constructor(message: string) }</signature>
      <path>documine/src/lib/errors.ts (NEW)</path>
    </interface>
    <interface>
      <name>ValidationError</name>
      <kind>class</kind>
      <signature>class ValidationError extends Error { code: 'VALIDATION_ERROR'; constructor(message: string) }</signature>
      <path>documine/src/lib/errors.ts (NEW)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing standards follow Next.js App Router conventions. API routes tested via HTTP endpoints. Error boundaries tested by triggering errors in child components. Build verification via npm run build ensures TypeScript compiles without errors. Test endpoints (like /api/test-errors) provide manual verification during development.
    </standards>
    <locations>
      <location>documine/src/app/api/test-errors/route.ts - Test endpoint for error handling verification</location>
      <location>documine/ - npm run build for TypeScript compilation verification</location>
    </locations>
    <ideas>
      <idea ac="AC-1.5.1">Test each error class can be instantiated and has correct code property</idea>
      <idea ac="AC-1.5.1">Test error classes extend Error and are throwable</idea>
      <idea ac="AC-1.5.2">Test successResponse returns 200 with { data, error: null }</idea>
      <idea ac="AC-1.5.2">Test errorResponse returns correct status with { data: null, error: {...} }</idea>
      <idea ac="AC-1.5.3">Test log.info outputs JSON with level 'info' and timestamp</idea>
      <idea ac="AC-1.5.3">Test log.error includes stack trace in output</idea>
      <idea ac="AC-1.5.4">Test error boundary renders fallback UI when child throws</idea>
      <idea ac="AC-1.5.4">Test reset function allows retry</idea>
      <idea ac="AC-1.5.5">npm run build completes without errors</idea>
    </ideas>
  </tests>
</story-context>
